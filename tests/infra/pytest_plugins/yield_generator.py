from __future__ import annotations

from collections.abc import Iterable
from pathlib import Path
from typing import Any, Mapping

import _pytest
import pytest

from eth2spec.gen_helpers.gen_base.dumper import Dumper
from eth2spec.test import context
from eth2spec.test.helpers.typing import SpecForkName
from tests.infra.manifest import Manifest

RUNNERS = ["kzg", "epoch_processing"]

MultiPhaseResult = dict[SpecForkName, list]


class SpecTestFunction(pytest.Function):
    """Custom pytest.Function subclass that captures test results.

    This class extends pytest.Function to store test vectors generated by
    spec tests, supporting both single-phase and multi-phase test results.

    Attributes:
        result: Test result data, either a list (single-phase) or a dict
                mapping fork names to lists (multi-phase)
    """

    result: MultiPhaseResult | list | None = None

    @classmethod
    def from_function(cls, f: pytest.Function) -> SpecTestFunction:
        """
        Create a SpecTestFunction from an existing pytest.Function.
        """
        self = cls.from_parent(
            parent=f.parent,
            name=f.name,
            callspec=getattr(f, "callspec", None),
            callobj=getattr(f, "_obj", _pytest.compat.NOTSET),
            keywords=f.keywords,
            fixtureinfo=getattr(f, "_fixtureinfo", None),
            originalname=f.originalname,
        )
        self.manifest_guess()

        return self

    def manifest_guess(self) -> None:
        print("guessing manifest for:", self.name)
        path = self.parent.path
        str_path = str(path)
        filename = path.name

        possible_runners = [runner for runner in RUNNERS if runner in str_path]
        if len(possible_runners) == 1:
            runner_name = possible_runners[0]
        else:
            return

        handler_name = filename.replace("test_", "").replace(".py", "")

        suite_name = getattr(self.obj, "suite_name", "pyspec_tests")

        case_name = self.name
        if case_name.startswith("test_"):
            case_name = case_name[5:]

        manifest = Manifest(
            runner_name=runner_name,
            handler_name=handler_name,
            case_name=case_name,
            suite_name=suite_name,
        )

        if hasattr(self.obj, "manifest") and self.obj.manifest is not None:
            manifest = self.obj.manifest.override(manifest)

        self.obj.manifest = manifest

    def runtest(self):
        super().runtest()

    def get_manifest(self) -> Manifest | None:
        if not hasattr(self.obj, "manifest") or self.obj.manifest is None:
            return None
        return self.obj.manifest

    def get_result(self) -> MultiPhaseResult | list | None:
        return self.result


class YieldGeneratorPlugin:
    output_dir: str = "generated-tests"
    dumper: Dumper | None = None

    def __init__(self, config):
        self.config = config

    def register(self):
        self.config.pluginmanager.register(self, "yield_generator")

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(self, pyfuncitem: pytest.Function):
        if not isinstance(pyfuncitem, SpecTestFunction):
            return False

        pyfuncitem.result = None

        testfunction = pyfuncitem.obj
        if _pytest.compat.is_async_function(testfunction):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
        result = testfunction(**testargs)
        if hasattr(result, "__await__") or hasattr(result, "__aiter__"):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        elif result is not None:
            if not isinstance(result, dict) and isinstance(result, Iterable):
                pyfuncitem.result = list(result)
            else:
                pyfuncitem.result = result
        return True

    @pytest.hookimpl(hookwrapper=True)
    def pytest_runtest_protocol(self, item, nextitem):
        print(f"\nRunning test: {item.name}")

        yield

        if self.config.getoption("--pytest-reftests") is False:
            return

        if not isinstance(item, SpecTestFunction):
            return

        manifest = item.get_manifest()
        result = item.get_result()

        if manifest is not None:
            print(f"\nManifest from {item.name}:")
            print(manifest)
        else:
            print(f"\nNo manifest found for {item.name}")

        if manifest is not None and result is None:
            print(f"\nWarning: manifest but vector not created for {item.name}")

        if result is not None:
            if isinstance(result, dict) and isinstance(list(result.keys())[0], str):
                print(f"\nMulti-phase test result for {item.name}")
            else:
                print(f"\nSingle-phase test result for {item.name}")

        if manifest is not None and result is not None:
            self.generate_test_vector(manifest, result)

    def pytest_collection_modifyitems(self, config, items):
        if self.config.getoption("--pytest-reftests") is False:
            return

        for i, item in enumerate(items):
            if isinstance(item, pytest.Function):
                # Replace with custom item
                items[i] = SpecTestFunction.from_function(item)

    def pytest_addoption(self, parser):
        """Add custom command-line options"""
        parser.addoption(
            "--pytest-reftests", action="store_true", default=True, help="Vector tests generation"
        )

    def pytest_configure(self, config):
        if config.getoption("--pytest-reftests"):
            context.is_python = True
            context.is_generator = True

    def generate_test_vector(self, manifest: Manifest, result: MultiPhaseResult | list) -> None:
        if isinstance(result, dict):
            for fork_name, phase_result in result.items():
                self.generate_test_vector_phase(manifest, phase_result, fork_name)

    def generate_test_vector_phase(
        self, manifest: Manifest, phase_result: list, fork_name: SpecForkName
    ) -> None:
        dumper = self.get_dumper()

        manifest = manifest.override(Manifest(fork_name=fork_name, preset_name="mainnet"))
        assert manifest.is_complete(), (
            f"Manifest must be complete to generate test vector for {manifest}"
        )

        dir = (
            Path(self.output_dir)
            / manifest.preset_name  # type: ignore
            / manifest.fork_name
            / manifest.runner_name
            / manifest.handler_name
            / manifest.suite_name
            / manifest.case_name
        )

        outputs: list[tuple[str, str, Any]] = []
        meta: dict[str, Any] = {}

        for name, kind, data in phase_result:
            if kind == "meta":
                meta[name] = data
            else:
                method = getattr(dumper, f"dump_{kind}", None)
                if method is None:
                    raise ValueError(f"Unknown kind {kind!r}")
                outputs.append((name, kind, data))

        for name, kind, data in outputs:
            method = getattr(dumper, f"dump_{kind}")
            method(dir, name, data)

    def get_dumper(self):
        if self.dumper is None:
            self.dumper = Dumper()
        return self.dumper


def pytest_configure(config):
    """Register the plugin."""
    YieldGeneratorPlugin(config).register()
