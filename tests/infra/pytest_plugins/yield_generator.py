from __future__ import annotations

from collections.abc import Iterable
from pathlib import Path
from typing import Any, TypedDict

import _pytest
import pytest

from eth2spec.gen_helpers.gen_base.dumper import Dumper
from eth2spec.test import context
from eth2spec.test.helpers.typing import SpecForkName
from tests.infra.manifest import Manifest


class RunnerConfig(TypedDict, total=False):
    runner_name: str
    handler_name_fixed: str
    handler_name_map: dict[str, str]
    handler_name_strip: list[str]
    suite_name: str


RUNNERS: dict[str, RunnerConfig] = {
    # Simple runners: pkg == runner_name, default handler_name (strip "test_")
    "bls": {},
    "finality": {},
    "fork_choice": {},
    "genesis": {},
    "kzg": {},
    "merkle_proof": {},
    "networking": {},
    "random": {},
    "rewards": {},
    "ssz_static": {},
    "sync": {},
    # Operations: path has "block_processing", runner is "operations"
    "block_processing": {
        "runner_name": "operations",
        "handler_name_map": {
            "test_process_sync_aggregate_random": "sync_aggregate",
        },
        "handler_name_strip": ["test_process_"],
    },
    # Epoch processing with custom handler derivation
    "epoch_processing": {
        "handler_name_map": {
            "test_apply_pending_deposit": "pending_deposits",
        },
        "handler_name_strip": ["test_process_", "test_apply_"],
    },
    # Sanity with special-case mappings
    "sanity": {
        "handler_name_map": {
            "test_deposit_transition": "blocks",
            "test_lookahead": "blocks",
            "test_lookahead_slots": "slots",
        },
    },
    # Light client
    "light_client": {
        "handler_name_map": {
            "test_sync_protocol": "sync",
        },
    },
    # Fork with fixed handler
    "fork": {
        "handler_name_fixed": "fork",
    },
    # Transition with fixed handler
    "transition": {
        "handler_name_fixed": "core",
    },
    # Shuffling with fixed handler and custom suite
    "shuffling": {
        "handler_name_fixed": "core",
        "suite_name": "shuffle",
    },
}

MultiPhaseResult = dict[SpecForkName, list]


class SpecTestFunction(pytest.Function):
    """Custom pytest.Function subclass that captures test results.

    This class extends pytest.Function to store test vectors generated by
    spec tests, supporting both single-phase and multi-phase test results.

    Attributes:
        result: Test result data, either a list (single-phase) or a dict
                mapping fork names to lists (multi-phase)
    """

    result: MultiPhaseResult | list | None = None

    @classmethod
    def from_function(cls, f: pytest.Function) -> SpecTestFunction:
        """
        Create a SpecTestFunction from an existing pytest.Function.
        """
        self = cls.from_parent(
            parent=f.parent,
            name=f.name,
            callspec=getattr(f, "callspec", None),
            callobj=getattr(f, "_obj", _pytest.compat.NOTSET),
            keywords=f.keywords,
            fixtureinfo=getattr(f, "_fixtureinfo", None),
            originalname=f.originalname,
        )
        self.manifest_guess()

        return self

    @staticmethod
    def _find_runner(path: Path) -> tuple[str, RunnerConfig] | None:
        """Walk up parent directories to find the closest matching runner pkg.

        Skips unittests directories (not associated with generators).
        Returns (pkg_name, config) or None.
        """
        for parent in path.parents:
            if parent.name == "unittests":
                return None
            if parent.name in RUNNERS:
                return parent.name, RUNNERS[parent.name]
        return None

    @staticmethod
    def _derive_handler_name(config: RunnerConfig, module_name: str) -> str:
        """Derive handler_name from runner config and module name."""
        if "handler_name_fixed" in config:
            return config["handler_name_fixed"]
        if module_name in config.get("handler_name_map", {}):
            return config["handler_name_map"][module_name]
        strips = config.get("handler_name_strip", ["test_"])
        handler_name = module_name
        for prefix in strips:
            handler_name = handler_name.removeprefix(prefix)
        return handler_name

    def manifest_guess(self) -> None:
        path = self.parent.path
        module_name = path.stem

        result = self._find_runner(path)
        if result is None:
            return
        pkg_name, config = result

        runner_name = config.get("runner_name", pkg_name)
        handler_name = self._derive_handler_name(config, module_name)
        suite_name = config.get("suite_name", getattr(self.obj, "suite_name", "pyspec_tests"))

        case_name = self.originalname or self.name
        if case_name.startswith("test_"):
            case_name = case_name[5:]

        preset = self.callspec.params.get("preset") if hasattr(self, "callspec") else None

        manifest = Manifest(
            runner_name=runner_name,
            handler_name=handler_name,
            case_name=case_name,
            suite_name=suite_name,
            preset_name=preset,
        )

        if hasattr(self.obj, "manifest") and self.obj.manifest is not None:
            manifest = self.obj.manifest.with_defaults(manifest)

        self.manifest = manifest

    def get_manifest(self) -> Manifest | None:
        if not hasattr(self, "manifest") or self.manifest is None:
            return None
        return self.manifest

    def get_result(self) -> MultiPhaseResult | list | None:
        return self.result


class YieldGeneratorPlugin:
    dumper: Dumper | None = None

    def __init__(self, config):
        self.config = config
        self.output_dir: str = config.getoption("--reftests-output")

    def register(self):
        self.config.pluginmanager.register(self, "yield_generator")

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(self, pyfuncitem: pytest.Function):
        if not isinstance(pyfuncitem, SpecTestFunction):
            return False

        pyfuncitem.result = None

        testfunction = pyfuncitem.obj
        if _pytest.compat.is_async_function(testfunction):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
        result = testfunction(**testargs)
        if hasattr(result, "__await__") or hasattr(result, "__aiter__"):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        elif result is not None:
            if not isinstance(result, dict) and isinstance(result, Iterable):
                pyfuncitem.result = list(result)
            else:
                pyfuncitem.result = result
        return True

    @pytest.hookimpl(hookwrapper=True)
    def pytest_runtest_protocol(self, item, nextitem):
        yield

        if self.config.getoption("--reftests") is False:
            return

        if not isinstance(item, SpecTestFunction):
            return

        manifest = item.get_manifest()
        result = item.get_result()

        if manifest is not None and result is None:
            item.warn(pytest.PytestWarning(f"manifest but vector not created for {item.name}"))

        if manifest is not None and result is not None:
            self.generate_test_vector(manifest, result)

    def pytest_collection_modifyitems(self, config, items):
        if self.config.getoption("--reftests") is False:
            return

        for i, item in enumerate(items):
            if isinstance(item, pytest.Function):
                # Replace with custom item
                items[i] = SpecTestFunction.from_function(item)

    def pytest_configure(self, config):
        if config.getoption("--reftests"):
            context.is_pytest = True
            context.is_generator = True

    def generate_test_vector(self, manifest: Manifest, result: MultiPhaseResult | list) -> None:
        if isinstance(result, dict):
            for fork_name, phase_result in result.items():
                self.generate_test_vector_phase(manifest, phase_result, fork_name)
        else:
            assert manifest.fork_name is not None, (
                f"fork_name must be set for single-phase test: {manifest}"
            )
            self.generate_test_vector_phase(manifest, result, manifest.fork_name)

    def generate_test_vector_phase(
        self, manifest: Manifest, phase_result: list, fork_name: SpecForkName
    ) -> None:
        dumper = self.get_dumper()

        manifest = manifest.with_defaults(Manifest(fork_name=fork_name))
        assert manifest.is_complete(), (
            f"Manifest must be complete to generate test vector for {manifest}"
        )

        output_dir = (
            Path(self.output_dir)
            / manifest.preset_name  # type: ignore
            / manifest.fork_name
            / manifest.runner_name
            / manifest.handler_name
            / manifest.suite_name
            / manifest.case_name
        )

        outputs: list[tuple[str, Any, Any]] = []
        meta: dict[str, Any] = {}

        for name, kind, data in phase_result:
            if kind == "meta":
                meta[name] = data
            else:
                method = getattr(dumper, f"dump_{kind}", None)
                if method is None:
                    raise ValueError(f"Unknown kind {kind!r}")
                outputs.append((name, method, data))

        for name, method, data in outputs:
            method(output_dir, name, data)

        if meta:
            dumper.dump_meta(output_dir, meta)

        dumper.dump_manifest(output_dir, {
            "preset": manifest.preset_name,
            "fork": manifest.fork_name,
            "runner": manifest.runner_name,
            "handler": manifest.handler_name,
            "suite": manifest.suite_name,
            "case": manifest.case_name,
        })

    def get_dumper(self):
        if self.dumper is None:
            self.dumper = Dumper()
        return self.dumper


def pytest_addoption(parser):
    """Add custom command-line options"""
    parser.addoption(
        "--reftests", action="store_true", default=False, help="Vector tests generation"
    )
    parser.addoption(
        "--reftests-output",
        default="generated-tests",
        help="Output directory for generated test vectors",
    )


def pytest_configure(config):
    """Register the plugin."""
    YieldGeneratorPlugin(config).register()
