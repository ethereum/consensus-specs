from __future__ import annotations

from collections.abc import Iterable
from typing import Mapping, Any

import _pytest
import pytest

from eth2spec.test.helpers.typing import SpecForkName
from tests.infra.manifest import Manifest

RUNNERS = ["kzg", "epoch_processing"]

MultiPhaseResult = dict[SpecForkName, list]


class SpecTestFunction(pytest.Function):
    """Custom pytest.Function subclass that captures test results.

    This class extends pytest.Function to store test vectors generated by
    spec tests, supporting both single-phase and multi-phase test results.

    Attributes:
        result: Test result data, either a list (single-phase) or a dict
                mapping fork names to lists (multi-phase)
    """

    result: MultiPhaseResult | list | None = None

    def __init__(
        self,
        name: str,
        parent,
        config: pytest.Config | None = None,
        callspec: _pytest.CallSpec2 | None = None,
        callobj=_pytest.compat.NOTSET,
        keywords: Mapping[str, Any] | None = None,
        session: pytest.Session | None = None,
        fixtureinfo: _pytest.fixtures.FuncFixtureInfo | None = None,
        originalname: str | None = None,
    ) -> None:
        super().__init__(
            name,
            parent,
            config=config,
            callspec=callspec,
            callobj=callobj,
            keywords=keywords,
            session=session,
            fixtureinfo=fixtureinfo,
            originalname=originalname,
        )


    def manifest_guess(self) -> None:
        print("guessing manifest for:", self.name)
        path = self.parent.path
        str_path = str(path)
        filename = path.name

        possible_runners = [runner for runner in RUNNERS if runner in str_path]
        if len(possible_runners) == 1:
            runner_name = possible_runners[0]
        else:
            return

        handler_name = filename.replace("test_", "").replace(".py", "")

        suite_name = getattr(self.obj, "suite_name", "pyspec_tests")

        case_name = self.name
        if case_name.startswith("test_"):
            case_name = case_name[5:]

        manifest = Manifest(
            runner_name=runner_name,
            handler_name=handler_name,
            case_name=case_name,
            suite_name=suite_name,
        )

        if hasattr(self.obj, "manifest") and self.obj.manifest is not None:
            manifest = self.obj.manifest.override(manifest)

        self.obj.manifest = manifest

    def runtest(self):
        super().runtest()

    @classmethod
    def from_function(cls, f: pytest.Function) -> SpecTestFunction:
        """
        Create a SpecTestFunction from an existing pytest.Function.
        """
        self = cls.from_parent(
            parent=f.parent,
            name=f.name,
            callspec=getattr(f, "callspec", None),
            callobj=getattr(f, "_obj", _pytest.compat.NOTSET),
            keywords=f.keywords,
            fixtureinfo=getattr(f, "_fixtureinfo", None),
            originalname=f.originalname,
        )
        self.manifest_guess()

        return self


class YieldGeneratorPlugin:
    def __init__(self, config):
        self.config = config

    def register(self):
        self.config.pluginmanager.register(self, "yield_generator")

    @pytest.hookimpl(tryfirst=True)
    def pytest_pyfunc_call(self, pyfuncitem: pytest.Function):
        pyfuncitem._result = None

        testfunction = pyfuncitem.obj
        if _pytest.compat.is_async_function(testfunction):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        funcargs = pyfuncitem.funcargs
        testargs = {arg: funcargs[arg] for arg in pyfuncitem._fixtureinfo.argnames}
        result = testfunction(**testargs)
        if hasattr(result, "__await__") or hasattr(result, "__aiter__"):
            _pytest.compat.async_fail(pyfuncitem.nodeid)
        elif result is not None:
            if not isinstance(result, dict) and isinstance(result, Iterable):
                pyfuncitem._result = list(result)
            else:
                pyfuncitem._result = result
        return True

    @pytest.hookimpl(hookwrapper=True)
    def pytest_runtest_protocol(self, item, nextitem):
        yield

        if hasattr(item.obj, "manifest") and item.obj.manifest is not None:
            print(f"\nManifest from {item.name}:")
            print(item.obj.manifest)
        else:
            print(f"\nNo manifest found for {item.name}")

        if hasattr(item.obj, "manifest") and (not hasattr(item, "_result") or item._result is None):
            print(f"\nWarning: manifest but vector not created for {item.name}")

        if hasattr(item, "_result") and item._result is not None:
            if isinstance(item._result, dict) and isinstance(list(item._result.keys())[0], str):
                print(f"\nMulti-phase test result for {item.name}")
            else:
                print(f"\nSingle-phase test result for {item.name}")

    def pytest_collection_modifyitems(self, config, items):
        for i, item in enumerate(items):
            if isinstance(item, pytest.Function):
                # Replace with custom item
                items[i] = SpecTestFunction.from_function(item)


def pytest_configure(config):
    """Register the plugin."""
    config.pluginmanager.register(YieldGeneratorPlugin(config), "yield_generator")
